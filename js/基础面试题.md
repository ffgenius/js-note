# html 经典面试题

## src和href区别

1. href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系。
2. src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。

## link和@import的区别

1. link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
4. link支持使用Javascript控制DOM去改变样式；而@import不支持。

## meta标签

1. `charset`，用来描述HTML文档的编码类型
2. `keywords`，页面关键词
3. `description`，页面描述
4. `refresh`，页面重定向和刷新
5. `viewport`，适配移动端，可以控制视口的大小和比例

## html5

1. 语义标签
2. 媒体标签 `<audio>` `<video>` `<source>`
3. 表单
4. web存储 `localStroage` `sessionStorage`

## sessionStorage 、localStorage和 cookie之间的区别

### 共同点：都是保存在浏览器端，且同源的

### 区别：

1.  cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
2.  存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
3.  数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
4.  作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。

## 渐进增强与优雅降级

渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。

优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

## iframe的优缺点

iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

### 优点：

1. 可以用来加载速度较慢的内容（如广告）。
2. 可以使脚本并行下载。
3. 可以实现跨子域tongxin

### 缺点：

1. iframe 会阻塞主页面的 onload 事件。
2. 无法被一些搜索引擎索识别。
3. 会产生很多页面，不容易管理。

## BFC

BFC块级格式化上下文。BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。

1. position:absolute或fixed；
2. float:left/right;
3. overflow:hidden; 
4. display:inline-block；

## 严格模式与混杂模式

1. 严格模式：以浏览器支持的最高标准运行。
2. 混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为。

## Canvas 和 SVG 有什么区别

Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。

### Canvas

1. 通过 Javascript 来绘制 2D 图形。
2. 是逐像素进行渲染的。
3. 其位置发生改变，会重新进行绘制。

### SVG

1. 一种使用 XML 描述的 2D 图形的语言。
2. SVG 基于 XML 意味着，SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。
3. 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

### 比较

**Canvas**

1. 依赖分辨率
2. 不支持事件处理器
3. 弱的文本渲染能力
4. 能够以 .png 或 .jpg 格式保存结果图像
5. 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

**SVG**

1. 不依赖分辨率
2. 支持事件处理器
3. 最适合带有大型渲染区域的应用程序（比如谷歌地图）
4. 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
5. 不适合游戏应用

### Viewport 属性值

1. width 设置 layout viewport 的宽度，为一个正整数，或字符串"width-device"
2. initial-scale 设置页面的初始缩放值，为一个数字，可以带小数
3. minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数
4. maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数
5. height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用
6. user-scalable 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。



# CSS 经典面试题

## 盒子模型

**IE盒子模型  border-box**

IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。

**W3C盒子模型  content-box** 

W3C标准盒模型：属性width，height只包含内容content，不包含border和paddin

## ::before 和:after 中双冒号和单冒号有什么区别

在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。

伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等

## 定位

### absolute

absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的paddingbox来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的paddingbox来定位，也就是说在计算定位距离的时候，padding的值也要算进去。

### relative

生成相对定位的元素，相对于其元素本身所在正常位置进行定位。

### fixed（老IE不支持）

生成绝对定位的元素，相对于浏览器窗口进行定位。

### static

默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。

### inherit

规定从父元素继承position属性的值。

## CSS3 有哪些新特性

1. 新增各种CSS选择器    （:not(.input)：所有class不是“input”的节点）
2. 圆角        （border-radius:8px）
3. 多列布局    （multi-columnlayout）
4. 阴影和反射    （Shadow\Reflect）
5. 文字特效        （text-shadow）
6. 文字渲染        （Text-decoration）
7. 线性渐变        （gradient）
8. 旋转            （transform）
9. 缩放，定位，倾斜，动画，多背景
10. 例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation

## width:auto 和 width:100%的区别

width:100%会使元素box的宽度等于父元素的contentbox的宽度。

width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。

## 清除浮动

1.  clear:both
2. overflow:hidden
3. after伪元素清除浮动
4. before和after双伪元素清除浮动
5. 父级div定义 height



# js 经典面试题

## js事件循环机制(event loop)

同步和异步任务分别进入不同的执行"场所"，同步的进入主
程，异步的进入Event Table并注册函数。

```javascript
console.log(1);
setTimeout(()=>{
  console.log(3);
},100)
console.log(2); // 1 2 3
```

## 微任务与宏任务

宏任务（macrotask ）和微任务（microtask ）表示异步任务的两种分类。常见宏任务：I/O 、setTimeout、  setInterval、setImmediate、requestAnimationFrame；
任务：Promise.then catch finally、process.nextTick

```javascript
setTimeout(()=>{
  console.log(4)
})
new Promise((res,rej)=>{
  console.log(1)
  res()
})
.then(()=>{
  console.log(3)
})
console.log(2)
```

每次宏任务执行完后都会清空队列里的微任务，微任务执行优先级高于宏任务。

## 普通函数可以new吗

可以，但是没有什么意义。（返回一个空的this有何用？）

```javascript
function a(){

}
console.log(new a());//a{}
```

## addEventListener中第三个参数

addEventListener(type, listener, useCapture);
控制函数是在捕获阶段执行还是在冒泡阶段执行,默认冒泡阶段false

## js垃圾回收机制

当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。
回收有两种方式：标记清除、引用计数。

标记清除：大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。

引用计数：机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。

## 闭包

闭包函数：声明在一个函数中的函数，叫做闭包函数。

闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。

特点：
让外部访问函数内部变量成为可能；

局部变量会常驻在内存中；

可以避免使用全局变量，防止全局变量污染；

会造成内存泄漏（有一块内存空间被长期占用，而不被释放）

```javascript
var name = '余光';

function foo() {
  console.log(name); // 余光 
}

foo(); //余光
```

## call、apply和bind的区别

相同点：
作用相同，都是动态修改this指向；都不会修改原先函数的this指向。

异同点：
(1)执行方式不同：

call和apply是改变后页面加载之后就立即执行，是同步代码。

bind是异步代码，改变后不会立即执行；而是返回一个新的函数。

(2)传参方式不同：

call和bind传参是一个一个逐一传入，不能使用剩余参数的方式传参。

apply可以使用数组的方式传入的，只要是数组方式就可以使用剩余参数的方式传入。

```javascript
const arr = [1, 2, 3, 4, 5, 6];
function fn(...b) {
  let a = b.reduce((sum, item) => sum += item, 0);
  console.log(this, b, a); // Window Array(6) 21
};
fn(...arr); 

const obj = {
  name: '张三',
};

fn.call(obj, 1, 2); // Object Array(2) 3
```

```javascript
function fn(a, b) {
  console.log(this, a + b); // Window 3
};
fn(1, 2); //window

const obj = {
  name: '张三',
};

fn.apply(obj, [3, 4]); //Object 7
```

```javascript
function fn(a, b) {
  console.log(this, a + b);
};
fn(1, 2); //Window 3 

const obj = {
  name: '张三',
};

let newfn = fn.bind(obj); 
newfn(5, 6); //Object 11
```

(3)修改this的性质不同：

call、apply只是临时的修改一次，也就是call和apply方法的那一次；当再次调用原函数的时候，它的指向还是原来的指向。

```javascript
function fn() {
  console.log(this);
};
fn(); //window

const obj = {
  name: '张三',
};

fn.call(obj); // Object
fn.apply(obj); // Object
fn(); //window
```

```javascript
function fn() {
  console.log(this);
};
fn(); //Window

const obj = {
  name: '张三',
};

let newfn = fn.bind(obj); 
newfn(); //Object
fn(); //Window 返回的是一个新的函数
```

## this指向

1、this指向直接调用者；
2、找不到调用者时即为window；

```javascript
function fun(){
console.log(this.num);
}
var obj = {
num:'1',
f:fun
}
var num = 2;
obj.f(); // 1 此处是obj调用了函数fun,所以fun函数内this指向obj,故而输出1
fun(); // 2 此处无明显调用者，顾指向window,所以输出2
```

```javascript
function foo() {
  console.log(this.a);
}
var obj2 = {
  a: 2,
  fn: foo
};
var obj1 = {
  a: 1,
  o1: obj2
};
obj1.o1.fn(); //2 此处fn的直接调用者是o1,即obj2；
```

```javascript
var a = 1;
setTimeout(function(){
  console.log(this.a) //1 定时器中的this指向window
},100)
```

```javascript
var a = 1;
function(){
  console.log(this.a) //1 匿名函数的this指向window
}()
```

## 原型与原型链

原型：
①所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象
②所有函数都有一个prototype(原型)属性，属性值是一个普通的对象
③所有引用类型的__proto__属性指向它构造函数的prototype

原型链：
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

①一直往上层查找，直到到null还没有找到，则返回undefined
②Object.prototype.__proto__ === null
③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象

Vue.prototype.axios = axios 在组件的实例对象this上挂载axios。

## 类型判定

```javascript
//typeof
typeof "";  //string
typeof 1;   //number
typeof false; //boolean
typeof undefined; //undefined
typeof function(){}; //function
typeof []; //object
typeof {}; //object
typeof Symbol(); //symbol
typeof null; //object
typeof NaN; // number
typeof new Date(); //object
typeof new RegExp(); //object

//instanceof
// instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。
{} instanceof Object; //true
[] instanceof Array;  //true
[] instanceof Object; //true
"123" instanceof String; //false
new String(123) instanceof String; //true

//constructor
"".constructor //ƒ String() { [native code] }
"".constructor == String //true
1.constructor //报错 Invalid or unexpected token
new Number(1).constructor //ƒ Function() { [native code] }
new Number(1).constructor == Number //false
new Date().constructor //ƒ Date() { [native code] }
new RegExp().constructor //ƒ RegExp() { [native code] }

//Object.prototype.toString()
Object.prototype.toString.call(""); //[object String]
Object.prototype.toString.call(1); //[object Number]
Object.prototype.toString.call(false); //[object Boolean]
Object.prototype.toString.call(undefined); //[object Undefined]
Object.prototype.toString.call(function(){}); //[object Function]
Object.prototype.toString.call([]); //[object Array]
Object.prototype.toString.call({}); //[object Object]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(null); //[object Null]
Object.prototype.toString.call(new Date()); //[object Date]
Object.prototype.toString.call(new RegExp()); //[object RegExp]
```

## null和undefined的区别

null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。当声明的变量还未被初始化时，变量的默认值为undefined。

null用来表示尚未存在的对象。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：
（1）变量被声明了，但没有赋值时，就等于undefined。
（2）调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。

null表示"没有对象"，即该处不应该有值。典型用法是：
（1）作为函数的参数，表示该函数的参数不是对象。
（2）作为对象原型链的终点。

## new操作符具体干了什么

1、创建一个空的对象

```javascript
var obj = {};
```

2、让空对象的原型属性指向原型链，设置原型链

```javascript
obj.__proto___ = Func.prototype;
```

3、让构造函数的this指向obj，并执行函数体

```javascript
var result = Func.call(obj);
```

4、判断返回类型，如果是值就返回这个obj，如果是引用类型，返回这个引用对象。

```javascript
if (typeof(result) == "object"){
  func = result;
}
else{
    func = obj;
}
```

## ajax原理

1、创建对象

```javascript
var xhr = new XMLHttpRequest();
```

2、打开请求

```javascript
xhr.open('GET', 'example.txt', true);
```

3、发送请求

```javascript
xhr.send(); //发送请求到服务器
```

4、接收响应

```javascript
xhr.onreadystatechange = function(){}
```

(1)当readystate值从一个值变为另一个值时，都会触发readystatechange事件。
(2)当readystate==4时，表示已经接收到全部响应数据。
(3)当status ==200时，表示服务器成功返回页面和数据。
(4)如果(2)和(3)内容同时满足，则可以通过xhr.responseText，获得服务器返回的内容。

## 防抖和节流

1.防抖(debounce)：触发高频事件 n 秒后函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间
举例：就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。

通过定时器，如果定时器还没结束触发第二次，则将上一次定时器清空，执行新的一个定时器，直到事件完成。

2.节流(thorttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。也可以是轮询的稀释，不需要在请求成功后立马再次发出请求。
举例：就比如抢购时，明明显示的是有产品，购买时却一直提示库存不足，过一会眼睁睁的看着它数值变成了0 。

利用时间戳，将此时的时间戳减去上一次执行的时间戳，如果时间没大于规定时间，则无法执行事件。

### 区别

防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。

## Symbol

Symbol 是 ES6 新推出的一种基本类型，它表示独一无二的值。它最大的用途就是用来定义对象唯一的属性名，就能保证不会出现同名的属性，还能防止某一个属性被不小心覆盖。

### 用法

通过Symbol()方法可以生成一个symbol，里面可以带参数，也可以不带参数。

### Symbol 类型的注意点

- Symbol 函数前不能使用 new 命令，否则会报错。
- Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
- Symbol值不能与其他类型值运算，不能转数值；可以转字符串和布尔值
不能用.运算符，要用方括号
- Symbol 作为属性名时，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys() 返回。
- Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
- Symbol.for 接受一个字符串作为参数，首先在全局中搜索有没有以该参数为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。

## javaScript常用的字符串方法

1. length 属性返回字符串的长度

2. toLowerCase(): 把字符串转为小写，返回新的字符串

3. toUpperCase(): 把字符串转为大写，返回新的字符串

4. charAt(): 返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串

5. charCodeAt() 方法返回字符串中指定索引的字符 unicode 编码,这个返回值是 0 - 65535 之间的整数

   **注意**：如果index不在0-str.length(不包含str.length)之间，返回NaN。

6. indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置

   **注意**：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。

7. lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置

   **注意**：lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。

8. search执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。

9. replace(): 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串

10. concat() 将两个或多个字符的文本组合起来，返回一个新的字符串。

11. match(): 返回所有查找的关键字内容的数组

12. trim() 方法删除字符串两端的空白符

13. slice(): 返回字符串中提取的子字符串

    ```javascript
    var str="Hello World";
    var str1=str.slice(2); //如果只有一个参数，则提取开始下标到结尾处的所有字符串
    var str2=str.slice(2,7); //两个参数，提取下标为2，到下标为7但不包含下标为7的字符串
    var str3=str.slice(-7,-2); //如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串
    
    console.log(str1); //llo World
    console.log(str2); //llo W
    console.log(str3); //o Wor
    ```

14. substring(): 提取字符串中介于两个指定下标之间的字符

    ```javascript
    var str="Hello World";
    var str1=str.substring(2)
    var str2=str.substring(2,2);
    var str3=str.substring(2,7);
    console.log(str1); //llo World
    console.log(str2); //如果两个参数相等，返回长度为0的空串
    console.log(str3); //llo W
    ```

15. substr(): 返回从指定下标开始指定长度的的子字符串

    ```javascript
    var str="Hello World";
    var str1=str.substr(1) // 如果没有指定length,返回从下标开始处结尾处的所有字符串
    var str2=str.substr(1,3);
    var str3=str.substr(-3,2);
    console.log(str1); //ello World 
    console.log(str2); //ell
    console.log(str3); //rl
    ```

16. split(): 把字符串分割成字符串数组

    ```javascript
    var str="AA BB CC DD";
    var string1="1:2:3:4:5";
    var str1=str.split("");//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割
    var str2=str.split(" "); //以空格为分隔符
    var str3=str.split("",4); //4指定返回数组的最大长度
    var str4=string1.split(":");
    console.log(str1); // ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]
    console.log(str2); //["AA" "BB" "CC" "DD"]
    console.log(str3); //["A", "A", " ", "B"]
    console.log(str4); // ["1", "2", "3", "4", "5"]
    ```

## javaScript常用数组方法

### push()

功能: 在数组最后一位添加一个或多个元素,并返回新数组的长度,改变原数组.(添加多个元素用逗号隔开)

```javascript
var arr = [1, 2, "c"];
var rel = arr.push("A", "B");
console.log(arr); // [1, 2, "c", "A", "B"]
console.log(rel); //  5  (数组长度)
```

### pop()

功能：删除数组的最后一位，并且返回删除的数据，会改变原来的数组。(该方法不接受参数,且每次只能删除最后一个)

```javascript
var arr = [1, 2, "c"];
var rel = arr.pop();
console.log(arr); // [1, 2]
console.log(rel); // c
```

### shift()

功能：删除数组的第一位数据，并且返回被删除的数据，会改变原来的数组。(该方法同pop()；一样不接受参数,且每次只能删除数组第一个)

```javascript
var arr = ["a","b", "c"];
var rel = arr.shift();
console.log(arr); // ['b', "c"]
console.log(rel); // a
```

### unshift()

功能： 在数组第一位添加一个或多个元素，并返回新数组的长度，改变原数组。(添加多个元素用逗号隔开)

```javascript
var arr = [1, 2, "c"];
var rel = arr.unshift("A", "B");
console.log(arr); // [ "A", "B",1, 2, "c"]
console.log(rel); //  5  (数组长度)
```

### sort()

功能：方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。

```javascript
var arr1 = [10, 1, 5, 2, 3];
arr1.sort();
console.log(arr1); // 1 10 2 3 5
```

如果 function(a, b) {return: a - b;} ，=> a - b < 0 那么 a 会被排列到 b 之前; (从小到大排序)
如果 function(a, b) {return: b - a;} ，=> b - a > 0 那么 b 会被排列到 a 之前; (从大到小排序)

```javascript
var arr = [10, 1, 5, 2, 3];
arr.sort(function (a, b) {
  return a - b;
});
console.log(arr); // 1 2 3 5 10
```

### reverse()

功能：将数组的数据进行反转，并且返回反转后的数组，会改变原数组。

```javascript
var arr = [1, 2, 3, "a", "b", "c"];
var rel = arr.reverse();
console.log(arr); //    ["c", "b", "a", 3, 2, 1]
console.log(rel); //    ["c", "b", "a", 3, 2, 1]
```

### splice()

功能：向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素所组成的数组。可以实现数组的增删改。

arrayObject.splice(index,howmany,item1,…,itemX)
index 必需。整数，规定添加/删除项目的位置（元素下标），使用负数可从数组结尾处规定位置。
howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。
item1, …, itemX 可选。向数组添加的新项目。

```javascript
var arr = ["a", "b", "c", 2, 3, 6];
var rel = arr.splice(2, 1, "add1", "add2");
console.log(arr); // a b add1 add2 2 3 6
console.log(rel); // c 
```

### concat()

功能： 数组的拼接(将多个数组或元素拼接形成一个新的数组),不改变原数组。

```javascript
var arr1 = [1, 2, 3];
var arr2 = ["a", "b", "c"];
var arr3 = ["A", "B", "C"];
var rel = arr1.concat(arr2, arr3);
console.log(arr1); // 1 2 3
console.log(rel); // 1 2 3 a b c A B C
```

### join()

功能：用特定的字符,将数组拼接形成字符串 (默认",")。

```javascript
var list = ["a", "b", "c", "d"]; // "a-b-c-d"
var result = list.join("-");     //"a-b-c-d"
var result = list.join("/");     //"a/b/c/d"
var result = list.join("");      //"abcd"
var result = list.join();        //  a,b,c,d
console.log(result);
```

### slice()

功能：裁切指定位置的数组，返回值为被裁切的元素形成的新数组 ，不改变原数组。
同concat() 方法 slice() 如果不传参数,会使用默认值,得到一个与原数组元素相同的新数组 (复制数组)

arr[].slice(startIndex,endIndex)
startIndex 起始下标 默认值 0
endIndex 终止下标 默认值 length,可以接收负数,(倒着数)

```javascript
var list = ["a", "b", "c", "d"];
var result = list.slice(1, 3);
console.log(result);  // ["b", "c"] 左闭右开
```

### toString()

功能: 直接将数组转换为字符串,并且返回转换后的新数组,不改变原数组,与join()方法不添加任何参数相同。

```javascript
var list = ["a", "b", "c", "d"];
var rel = list.toString();
console.log(rel);   // a,b,c,d   (字符串类型)
```

### valueOf()

功能: 返回数组的原始值（一般情况下其实就是数组自身）。

```javascript
var list = [1, 2, 3, 4];
var rel = list.valueOf();
console.log(list); // [1, 2, 3, 4]
console.log(rel); // [1, 2, 3, 4]
```

### indexOf()

功能: 查询某个元素在数组中第一次出现的位置 存在该元素,返回下标,不存在 返回 -1 (可以通过返回值 变相的判断是否存在该元素)。

```javascript
var list = [1, 2, 3, 4];
var index = list.indexOf(4); //3
var index = list.indexOf("4"); //-1
console.log(index);
```

### lastIndexOf()

功能: 查询某个元素在数组中最后一次出现的位置 (或者理解为反向查询第一次出现的位置) 存在该元素,返回下标,不存在 返回 -1 (可以通过返回值 变相的判断是否存在该元素)。

```javascript
var list = [1, 2, 3, 4];
var index = list.lastIndexOf(4); //3
var index = list.lastIndexOf("4"); //-1
console.log(index);
```

### forEach()

功能: 遍历数组,每次循环中执行传入的回调函数。(注意: forEach() 对于空数组是不会执行回调函数的。) 没有返回值,或理解为返回值为undefined,不改变原数组。

```javascript
arr[].forEach(function(value,index,array){
　 //do something
})
```

参数: value:每次循环的当前元素, index:当前项的索引, array:原始数组。

```javascript
var list = [32, 93, 77, 53, 38, 87];
var res = list.forEach(function (item, index, array) {
  console.log(item, index, array);
});
console.log(res);
```

### map()

功能: 遍历数组, 每次循环时执行传入的回调函数,根据回调函数的返回值,生成一个新的数组,同forEach() 方法,但是map()方法有返回值,可以return出来。

```javascript
arr[].map(function(item,index,array){
　//do something
  return XXX
})
```

参数： item:每次循环的当前元素, index:当前项的索引, array:原始数组；

```javascript
var list = [32, 93, 77, 53, 38, 87];
var res = list.map(function (item, index, array) {
  return item + 5 * 2;
});
console.log("原数组", list);
console.log("新数组", res);
```

### filter()

功能: 遍历数组, 每次循环时执行传入的回调函数,回调函数返回一个条件,把满足条件的元素筛选出来放到新数组中。

```javascript
arr[].filter(function(item,index,array){
　//do something
　return XXX //条件
})
```

参数： item:每次循环的当前元素, index:当前项的索引, array:原始数组。

```javascript
var list = [32, 93, 77, 53, 38, 87];
var resList = list.filter(function (item, index, array) {
  return item >= 60; // true || false
});
console.log(resList);
```

### every()

功能: 遍历数组, 每次循环时执行传入的回调函数,回调函数返回一个条件,全都满足返回true 只要有一个不满足 返回false => 判断数组中所有的元素是否满足某个条件。

```javascript
var list = [32, 93, 77, 53, 38, 87];
var result = list.every(function (item, index, array) {
  console.log(item, index, array);
  return item >= 50;
});
console.log(result); // false
```

### some()

功能: 遍历数组, 每次循环时执行传入的回调函数,回调函数返回一个条件,只要有一个元素满足条件就返回true,都不满足返回false => 判断数组中是否存在,满足某个条件的元素。

```javascript
var list = [32, 93, 77, 53, 38, 87];
var result = list.some(function (item, index, array) {
  console.log(item, index, array);
  return item >= 50;
});
console.log(result); // true
```

### reduce()

功能: 遍历数组, 每次循环时执行传入的回调函数,回调函数会返回一个值,将该值作为初始值prev,传入到下一次函数中, 返回最终操作的结果;

语法: arr.reduce(function(prev,item,index,array){})

参数:
prev 初始值 (类似求和是 sum=0) 可以设置初始值( 参数),如果不设置初始值默认是数组中的第一个元素,遍历时从第二个元素开始遍历
item 每次循环的当前元素
index 每次循环的当前下标
array 原数组

```javascript
var arr = [2, 3, 4, 5];
var sum = arr.reduce(function (prev, item, index, array) {
  console.log(prev, item, index, array);
  return prev + item;
});
console.log(arr, sum);
```

### reduceRight()

功能: 用法同reduce,只不过是从右向左。

```javascript
var arr = [2, 3, 4, 5];
var sum = arr.reduceRight(function (prev, item, index, array) {
  console.log(prev, item, index, array);
  return prev + item;
});
console.log(arr, sum);
```

### includes()

功能: 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。

```javascript
let site = ['runoob', 'google', 'taobao'];
 
site.includes('runoob'); 
// true 
 
site.includes('baidu'); 
// false
```

### Array.from()

功能: 将一个类数组对象或者可遍历对象转换成一个真正的数组。

注意 将一个类数组对象转换为一个真正的数组，必须具备以下条件：

1、该 伪数组 / 类数组 对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。
2、该 伪数组 / 类数组 对象的属性名必须为数值型或字符串型的数字。

```javascript
var all = {
  0: "张飞",
  1: "28",
  2: "男",
  3: ["率土", "鸿图", "三战"],
  length: 4,
};
var list = Array.from(all);
console.log(all);
console.log(list, Array.isArray(list));
```

### find()

功能: 遍历数组 每次循环 执行回调函数,回调函数接受一个条件 返回满足条件的第一个元素,不存在则返回undefined。

参数:
item:必须 , 循环当前元素
index:可选 , 循环当前下标
array:可选 , 当前元素所属的数组对象

```javascript
var list = [55, 66, 77, 88, 99, 100];
var res= list.find(function (item, index, array) {
  return item > 60;
});
console.log(res); //66
```

该方法可快速查找对象数组满足条件的项

```javscript
let arr = [{ id: 1, name: 'coco' }, { id: 2, name: 'dudu' }]
let res = arr.find(item => item.id == 1)
console.log('res', res)  //res {id: 1, name: "coco"}
```

### findIndex()

功能 遍历数组,执行回调函数,回调函数接受一个条件,返回满足条件的第一个元素下标,不存在则返回-1。

参数
item:必须 , 循环当前元素
index:可选 , 循环当前下标
array:可选 , 当前元素所属的数组对象

注意
findIndex();和indexOf();不同 (刚接触时乍一看和indexOf()怎么一模一样,仔细看了下才发现大有不同)
indexOf是传入一个值.找到了也是返回索引,没有找到也是返回-1 ,属于ES5
findIndex是传入一个测试条件,也就是函数,找到了返回当前项索引,没有找到返回-1. 属于ES6

```javascript
var list = [55, 66, 77, 88, 99, 100];
var index = list.findIndex(function (item, index, array) {
  console.log(item, index, array);
  return item > 60;
});
console.log(index); // 1
```

该方法可快速查找对象数组满足条件的索引，indexOf不支持

```javascript
let arr = [{ id: 1, name: 'coco' }, { id: 2, name: 'dudu' }]
let res = arr.findIndex(item => item.id == 1)
console.log('res', res)  //res 0
```

### fill()

功能 用给定值填充一个数组。

参数
value 必需。填充的值。
start 可选。开始填充位置。
end 可选。停止填充位置 (默认为 array.length)

```javascript
var result = ["a", "b", "c"].fill("填充", 1, 2);
console.log('result', result)  // a 填充 b
```

### flat()

功能： 用于将嵌套的数组"拉平",变成一维的数组。该方法返回一个新数组，对原数据没有影响。

注意： 默认拉平一次 如果想自定义拉平此处 需要手动传参 ,如果想全都拉平 传 Infinity

```javascript
var list = [1, 2, [3, 4, [5]]];
var arr = list.flat(); // 默认拉平一次
console.log("拉平一次", arr); // [1, 2, 3, 4, [5]]

var arr = list.flat(2); // 拉平2次
console.log("拉平两次", arr); // [1, 2, 3, 4, 5]
```

### flatMap()

功能： flat()和map()的组合版 , 先通过map()返回一个新数组,再将数组拉平( 只能拉平一次 )

```javascript
var list = [55, 66, 77, 88, 99, 100];
var newArr = list.map(function (item, index) {
  return [item, index];
});
console.log("Map方法:", newArr);

var newArr = list.flatMap(function (item, index) {
  return [item, index];
});
console.log("flatMap方法:", newArr);
```

## Map 和 Set

Map是一组键值对的结构，具有极快的查找速度。

```javascript
var names = ['Michael', 'Bob', 'Tracy'];
var scores = [95, 75, 85];
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
```

初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：

```javascript
var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
```

Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set

```javascript
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
```

重复元素在Set中自动被过滤

```javascript
var s = new Set([1, 2, 3, 3, '3']);
console.log(s); // Set {1, 2, 3, "3"}
```

通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：

```javascript
s.add(4);
console.log(s); // Set {1, 2, 3, 4}
s.add(4);
console.log(s); // 仍然是 Set {1, 2, 3, 4}
```

通过delete(key)方法可以删除元素：

```javascript
var s = new Set([1, 2, 3]);
console.log(s); // Set {1, 2, 3}
s.delete(3);
console.log(s); // Set {1, 2}
```

## Map 和 Object 的区别

### 概念

#### Object

在ECMAScript中，Object是一个特殊的对象。它本身是一个顶级对象，同时还是一个构造函数，可以通过它（如：new Object()）来创建一个对象。我们可以认为JavaScript中所有的对象都是Object的一个实例，对象可以用字面量的方法const obj = {}即可声明。

#### Map

Map是Object的一个子类，可以有序保存任意类型的数据，使用键值对去存储，其中键可以存储任意类型，通过const m = new Map();即可得到一个map实例。

### 访问属性

map: 通过map.get(key)方法去属性, 不存在则返回undefined

object: 通过obj.a或者obj[‘a’]去访问一个属性, 不存在则返回undefined

### 添加属性

map: 通过map.set去设置一个值，key可以是任意类型

object: 通过object.a = 1或者object[‘a’] = 1，去赋值，key只能是字符串，数字或symbol

### 删除属性

map: 通过map.delete去删除一个值，试图删除一个不存在的属性会返回false

object: 通过delete操作符才能删除对象的一个属性，诡异的是，即使对象不存在该属性，删除也返回true，当然可以通过Reflect.deleteProperty(target, prop) 删除不存在的属性还是会返回true。

## JSON

### 含义

JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）
JSON 是轻量级的文本数据交换格式
JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。
JSON 具有自我描述性，更易理解

### 语法

JSON 语法是 JavaScript 语法的子集。

JSON用键值对形式存在 e.g.{“key”:”value”}

### JSON常用方法

JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。
JSON.stringify():于将 JavaScript 值转换为 JSON 字符串。

## 类数组对象

理解：是JS中一种特殊的对象。本质上来说对象是满足了一定条件的数组，类数组的使用目的在于使得一个对象既有数组的特性也具有对象的特性。

```javascript
var arr = ['name', 'age', 'sex']; // 数组
var arrLike = {
  0: 'name',
  1: 'age',
  2: 'sex',
  length: 3
} // 类数组
```

类数组对象与数组的性质相似，因为类数组对象在访问、赋值、获取长度上的操作与数组一致。

数组与类数组对象的访问

```javascript
console.log(arr[0]); // name
console.log(arrLike[0]); // name
```

数组与类数组对象的赋值

```javascript
arr[0] = 'newName';
arrLike[0] = 'newName';
```

获取数组与类数组对象的长度

```javascript
console.log(arr.length); // 3
console.log(arrLike.length); // 3
```

类数组与数组的区别：类数组对象不能直接使用数组的方法

类数组对象使用数组方法时会报错

```javascript
arrLike.push('address');  // Uncaught TypeError: arrLike.push is not a function
```

### 类数组使用数组方法

```javascript
// 使用 call 方法
Array.prototype.push.call(arrLike, 'address');
console.log(arrLike); // { '0': 'name', '1': 'age', '2': 'sex', '3': 'address', length: 4 }
var arrLikeStr = Array.prototype.join.call(arrLike, '&')
console.log(arrLikeStr); // name&age&sex&address
```

```javascript
// 使用 apply 方法
Array.prototype.push.apply(arrLike, ['address']);
console.log(arrLike); // { '0': 'name', '1': 'age', '2': 'sex', '3': 'address', length: 4 }
var arrLikeStr = Array.prototype.join.apply(arrLike, ['&'])
console.log(arrLikeStr); // name&age&sex&address
```

### 类数组转化为数组

```javascript
// 使用 call 方法
console.log(Array.prototype.slice.call(arrLike,0));
console.log(Array.prototype.splice.call(arrLike,0));  // 会改变原先的类数组对象
```

```javascript
// 使用 apply 方法
console.log(Array.prototype.slice.apply(arrLike,[0]));
console.log(Array.prototype.splice.apply(arrLike,[0]));  // 会改变原先的类数组对象
```

## arguments

在函数体中定义 Arguments 对象，其包含函数的参数和其它属性，以 arguments 变量来指代。

```javascript
function fn(name, age, sex) {
    console.log(arguments);
}

fn('Scojing', '20', '女')
```

```javascript
function fn(name, age, sex) {
    console.log(arguments.length);  // 2
}

fn('Scojing', '20')
```

## for..in 和 for..of 的区别

### for..in

for...in是为遍历对象属性而构建的，它以任意顺序遍历一个对象的除Symbol以外的可枚举属性，可用break或者throw跳出。

```javascript
let obj = {
  name: '张三',
  age: 18
}

for(let item in obj) {
  console.log(item)
}
// 输出 name age
```

在JavaScript中，数组也是对象的一种，所以数组也是可以使用for...in遍历

```javascript
let arr = ['a', 'b', 'c']

for(let item in arr) {
  console.log(item)
}
// 输出 0 1 2
```

### for..of

for...of语句在可迭代对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句（包括Array，Map，Set，String，TypedArray，arguments等等，不包括Object），可用break或者throw跳出。

```javascript
let arr = ['a', 'b', 'c']

let obj = {
  name: '张三',
  age: 18,
  sex: '男'
}

for (let i of arr) {
  console.log(i)
}
// 输出 a b c

for (let i of obj) {
  console.log(i)
}
// 报错 obj is not iterable (obj不是可迭代的)
```

### 两者区别

无论是for...in还是for...of都是迭代一些东西。它们之间的主要区别在于它们的迭代方式

- for...in语句以任意顺序迭代对象的可枚举属性

- for...of语句遍历可迭代对象定义要迭代的数据

```javascript
let arr = ['a', 'b', 'c']

Array.prototype.ufo = '张三'

for(let item in arr) {
  console.log(item)
}
// 输出 0 1 2 ufo

for(let item of arr) {
  console.log(item)
}
// 输出 a b c
```

## 使用for....of遍历对象的方法

### 遍历类数组对象

使用Array.from()方法将对象转换为数组

```javascript
var obj = {
  0:'one',
  1:'two',
  length: 2
};
obj = Array.from(obj);
for(var k of obj){
  console.log(k)
}
```

### 遍历普通对象

- 给对象添加一个[symbol.iterator]属性，并指向一个迭代器。

```javascript
var obj = {
    a:1,
    b:2,
    c:3
};

obj[Symbol.iterator] = function(){
  var keys = Object.keys(this);
  var count = 0;
  return {
    next(){
      if(count<keys.length){
        return {value: obj[keys[count++]],done:false};
      }else{
        return {value:undefined,done:true};
      }
    }
  }
};

for(var k of obj){
  onsole.log(k);
}
```

- 方法二（使用Generator函数生成迭代器）

```javascript
var obj = {
    a:1,
    b:2,
    c:3
};
obj[Symbol.iterator] = function*(){
    var keys = Object.keys(obj);
    for(var k of keys){
        yield [k,obj[k]]
    }
};

for(var [k,v] of obj){
    console.log(k,v);
}
```

## for 和 forEach区别

- for循环可以使用break跳出循环，但forEach不能。
- for循环可以控制循环起点（i初始化的数字决定循环的起点），forEach只能默认从索引0开始。
- for循环过程中支持修改索引（修改 i），但forEach做不到（底层控制index自增，无法左右它）。

## Promise

Promise 是异步编程的一种解决方案：从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。

promise有三种状态： pending(等待态)，fulfilled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。

promise是用来解决两个问题的：   回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象   promise可以支持多个并发的请求，获取并发请求中的数据   这个promise可以解决异步的问题，本身不能说promise是异步的。

## 普通函数和箭头函数的区别

1. 箭头函数没有prototype(原型)，箭头函数没有自己的this，继承的是外层代码块的this。
2. 不可以当做构造函数，也就是说不可以使用new命令，否则会报错的。
3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
4. 不可以使用yield命令，因此箭头函数不能用作 Generator（生成器） 函数。
5. 因为没有this，所以不能使用call、bind、apply来改变this的指向。

## 预加载和懒加载

### 懒加载

懒加载也叫延迟加载，延迟加载网络资源或符合某些条件时才加载资源。常见的就是图片延时加载。

意义：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

懒加载实现：

1. 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟。
2. 条件加载，符合某些条件，或触发了某些事件才开始异步下载。
3. 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。

### 预加载

提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。预加载应用如广告弹窗等。

## JavaScript定义类的四种方法

### 工厂方法

```javascript
function createPerson(name, age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.sayName = function() {
        alert(this.name);
    }
    return obj;
}
```

### 构造函数方法

```javascript
function Person(name, age) {
    this.name = name;
    this,age = age;
    this.sayName = function() {
        alert(this.name)
    }
}

var p1 = new Person('zhang'， 18);
var p2 = new Person('li'， 20);
```

### 原型方法

```javascript
function Person() {}
Person.prototype = {
    constructor : Person,
    name : 'Ning';
    age : 18;
    sayName : funciton() {
		alert(this.name)
    }
}
```

### 组合使用构造函数和原型方法

```javascript
function Person(name, age) {
	this.name = name;
    this.age = age;
}

Person.prototype = {
    constructor : Person;
    sayName : function() {
        alert(this.name);
    }
}
```

## JavaScript实现继承的3种方法

### 借用构造函数法

```javascript
function SuperType(name) {
	this.name = name;
	this.sayName = function() {
		alert(this.name)
	}
}

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
```

### 对象冒充

```javascript
function SuperType(name) {
    this.name = name;
    this.sayName = function() {
        alert(this.name);
    }
}

function SubType(name, age) {
    // 对象冒充
    this.supertype = SuperType;
    this.supertype(name);
    this.age = age;
}
```

### 组合继承

```javascript
function SuperType(name) {
    this.name = name;
}

SuperType.prototype = {
    sayName : function() {
        alert(this.name);
    }
}

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}

SubType.prototype = new SuperType();
```

## 回流和重绘

当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

### 回流

当元素结构、位置、尺寸或某些属性发生改变时，浏览器需要重新计算样式和渲染数。

触发：页面首次渲染、DOM树变化、元素尺寸或者位置发生变化。

### 重绘

当元素发生的改变只影响了节点的一些样式（背景色、边框颜色、文字颜色等），浏览器只需要将新样式赋予给这个元素并重绘他。

触发：背景色、颜色、字体改变

### 减少回流

1. 尽量避免改变和多次读取布局属性。
2. 节点元素脱离文档流。
3. 不在标签内使用type属性定义。

## XML与JSON的区别

1. 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。
2. 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
3. 数据描述方面。JSON对数据的描述性比XML较差。
4. 传输速度方面。JSON的速度要远远快于XML。

## 深浅拷贝

深浅拷贝是只针对Object和Array这样的引用数据类型的。

引用数据类型栈中储存的指针，堆中储存的是它的实体地址。

### 浅拷贝

浅拷贝只复制在栈内存中的指针，只是在栈内存复制出同样的地址，而不复制对象本身，新旧对象还是共享同一块内存。

### 深拷贝

深拷贝会在内存空间中创造一个一模一样的对象，将原对象遍历到新对象中，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## 跨域

跨域是浏览器的安全限制。

当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域。

### 跨域解决方法

#### 1. 设置document.domain解决无法读取非同源网页的cookie问题。

因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）

```javascript
// 两个页面都要设置
document.domain = 'test.com';
```

#### 2. JSONP

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。

核心思想：网页通过添加一个`<script>`元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

```html
// 原生实现

// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字
<script src="http://test.com/data.php?callback=dosomething"></script>

// 处理服务器返回回调函数的数据
<script type="text/javascript">
    function dosomething(res){
        // 处理获得的数据
        console.log(res.data)
    }
</script>
```

```javascript
// jQuery ajax
$.ajax({
    url: 'http://www.test.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
```

```javascript
// vue.js
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

#### 3. CORS

CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。

**1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin**

**2、带cookie跨域请求：前后端都需要进行设置**

**【前端设置】**根据xhr.withCredentials字段判断是否带有cookie

```javascript
// 原生ajax

// IE8/9需用window.XDomainRequest兼容
var xhr = new XMLHttpRequest(); 
 
// 前端设置是否带cookie
xhr.withCredentials = true;
 
xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');
 
xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
```

```javascript
// jQuery ajax

$.ajax({
   url: 'http://www.test.com:8080/login',
   type: 'get',
   data: {},
   xhrFields: {
       // 前端设置是否带cookie
       withCredentials: true 
   },
   // 会让请求头中包含跨域的额外信息，但不会含cookie
   crossDomain: true,  
});
```

```javascript
// Vue-resource

Vue.http.options.credentials = true;
```

```javascript
// axios

axios.defaults.withCredentials = true
```

## ES6模块化规范

ES6模块化规范是浏览器和服务端通用的模块化开发规范。

### ES6模块化规范中的定义

1. 每个js文件都是一个独立的模块。
2. 导入其他模块成员使用import关键字。
3. 向外共享模块成员使用export关键字。

### ES6模块化的基本语法

**export暴露**

1. 分别暴露 定义对象前加上export

   ```javascript
   export let name = 'Tom'
   export function play() {}
   ```

2. 统一暴露 先定义完所有数据，在统一暴露

   ```javascript
   let name = 'Tom'
   function play() {}
   
   export {name, play}
   ```

3. 默认暴露 将所有的数据写在default对象中

   ```javascript
   export default {
       name = 'Tom',
       play: function() {}
   }
   ```

**import引入**

1. 通用引入 三种暴露方式都可以引入

   ```javascript
   import * as m from 'url'
   
   // * : 代表引入改模块中的所有暴露数据
   // as : 重命名
   // as后面的紧跟的m就是别名，m代表引入的这个模块
   // url : 引入模块的地址
   
   // 如果引入的模块是默认暴露的
   m.default.xxx
   // 那么m里面会有一个default对象，这个对象里面保存着默认暴露的所有数据
   ```

2. 结构赋值形式 三种暴露方式都可以引入

   ```javascript
   import {name, play} from 'url'
   
   // name 和 play 是某个模块里面事先定义并暴露的数据
   // {name, play} 表示引入改模块中暴露的name 和play ，并用同名的变量保存
   
   // 因为会用同名变量保存引入的参数，所以很可能导致命名冲突
   import {name as n, play} from 'url'
   
   // 可以用 as 取别名，这样 n 就代表 name
   // 这时会用 变量n 保存 name
   
   // 如果引入的模块 是 默认暴露的
   import {default as m} from 'url'
   // m 里封装了所有暴露的数据
   ```

3. 简便形式  只适用于默认暴露的模块

   ```javascript
   import m from 'url'
   
   // url为默认暴露的模块，如果不是会报错
   // m 里封装了所有暴露的数据
   ```

**Script标签**

用到了模块化import 和 export 的 js 文件要是引入到 html 页面中的话 必须给script加上 type = "module" 这个属性
`<script type="module" src="url..."></script>`

## 事件冒泡和事件捕获

### 事件冒泡

事件由子元素传递到父元素的过程叫做冒泡。

**查找事件（事件响应）的顺序**：文本节点–>元素节点—>body—>html—>document（例如点击事件）<向上响应>

**阻止事件冒泡**

1. `事件委托`：将元素的绑定事件写起其父元素上，防止事件冒泡。
2. `event.stopPropagation()`：可以阻止事件冒泡，阻止父级元素的绑定事件。

### 事件捕获

事件由父元素传递到子元素的过程叫做事件捕获。**查找事件（事件响应）的顺序**：document–>html–>body–>元素节点–>文本节点 <向下响应>

## 阻止默认事件

1. `return false` 用于阻止默认事件
2. `事件名.Defalute();` 用于阻止默认事件
3. `event.preventDefault();` 用于阻止默认事件
4. `event.stopPropagation();` 用于阻止冒泡的默认事件

## 阻止冒泡事件

1. `event.stoppropagation()`
2. `return false`



# vue 经典面试题

## vue的优点

1. 轻量级框架
2. 简单易学
3. 双向数据绑定
4. 组件化
5. 视图，数据，结构分离
6. 虚拟DOM
7. 运行速度更快

## SPA单页面优缺点

### 理解

1. SPA（ single page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。
2. 一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。
3. 页面的变化是利用路由机制实现 HTML 内容的变换，避免页面的重新加载。

### 优点

1. 用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。
2. 减少了不必要的跳转和重复渲染，这样相对减轻了服务器的压力。
3. 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理。

### 缺点

1. 初次加载耗时多。
2. 不能使用浏览器的前进后退功能，由于单页应用在一个页面中显示所有的内容，所以，无法前进后退。
3. 不利于搜索引擎检索：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。。

## SPA首屏加载速度慢的怎么解决

首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容；

**加载慢的原因**

1. 网络延时问题。
2. 资源文件体积是否过大。
3. 资源是否重复发送请求加载。
4. 加载脚本的时候，渲染内容堵塞。

### 优化

1. 减小入口文件体积。
2. 静态资源本地缓存。
3. UI框架按需加载。
4. 图片资源的压缩。
5. 组件重复打包。
6. 开启GZip压缩。
7. 使用SSR。

## MVVM理解

MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来；ViewModel 是一个同步View 和 Model的对象。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

## Vue数据双向绑定原理

实现mvvm的数据双向绑定，是采用**数据劫持**结合**发布者-订阅者模式**的方式，通过Object.defineProperty()来给各个属性添加setter，getter并劫持监听，在数据变动时发布消息给订阅者，触发相应的监听回调。

## vue响应式原理

什么是响应式，也即是说，数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。
Object.defineProperty 为对象中的每一个属性，设置 get 和 set 方法，每个声明的属性，都会有一个 专属的依赖收集器 subs，当页面使用到 某个属性时，触发 ObjectdefineProperty - get函数，页面的 watcher 就会被 放到 属性的依赖收集器 subs 中，在 数据变化时，通知更新；
当数据改变的时候，会触发Object.defineProperty - set函数，数据会遍历自己的 依赖收集器 subs，逐个通知 watcher，视图开始更新。

## Vue3.x响应式原理

Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

## Proxy 与 Object.defineProperty 优劣对比

1. Proxy 可以直接监听对象而非属性；
2. Proxy 可以直接监听数组的变化；
3. Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
4. Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
5. Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；
6. Object.defineProperty 的优势如下:
   兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

## vue中组件的data为什么是一个函数？而new Vue 实例里，data 可以直接是一个对象

因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。使用函数后，使用的是data()函数，data()函数中的this指向的是当前实例本身，就不会相互影响了。而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

## vue中computed与method的区别

**相同点**

​	如果作为模板的数据显示，二者能实现响应的功能，唯一不同的是methods定义的方法需要执行。

**不同点**

1. computed 会基于响应数据缓存，methods不会缓存；
2. diff之前先看data里的数据是否发生变化，如果没有变化computed的方法不会执行，但methods里的方法会执行。
3. computed是属性调用，而methods是函数调用。

## react、vue中的key有什么作用？(key的内部原理)

### 虚拟DOM中的作用：

key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成的【新的虚拟DOM】，
随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的差异比较。

### 对比规则

1. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
       若虚拟DOM中内容没有改变，直接使用之前的虚拟DOM
       若虚拟DOM中的内容改变了，则生成新的真是DOM，随后替换掉页面中之前的真是DOM
2. 旧虚拟DOM中未找到与新虚拟DOM相同的key
       创建新的真是DOM，随后渲染到页面

### 用index作为key可能会引发的问题

1. 若对数据进行：逆序添加，逆序删除等破坏顺序操作：
   会产生没有必要的真是DOM更新 ==> 界面效果没问题，但是效率低
2. 如果结构中还包含输入类的DOM：
    会产生错误DOM更新 ==> 界面有问题

### 开发中如何选择key

1. 最好使用每条数据的唯一标识作为key，比如id，手机号，身份证号，学号等唯一标识。
2. 如果不存在对数据的逆序添加，逆序删除等破坏顺序操作，仅用于渲染列表用于展示。
使用index作为key是没有问题的。

## $nextTick

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

Vue更新DOM是异步的。数据变化时将开启一个队列，同一个watcher的多次触发，只会被加入队列一次，这样可以避免不必要的计算和DOM操作。

## vue常用指令

1. v-model指令：用于表单输入，实现表单控件和数据的双向绑定。
2. v-on：简写为@，基础事件绑定。
3. v-bind：简写为：，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。
4. v-if指令：取值为true/false，控制元素是否需要被渲染
5. v-else指令：和v-if指令搭配使用，没有对应的值。当v-if的值false，v-else才会被渲染出来。
6. v-show指令：指令的取值为true/false，分别对应着显示/隐藏。
7. v-for指令：遍历data中存放的数组数据，实现列表的渲染。
8. v-once： 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。
9. v-pre：跳过其节点的编译过程。可利用跳过没有使用指令语法，没有使用插值语法的节点，会加快编译。
10. v-cloak：本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。
11. v-text：向其所在的节点渲染文本内容。与插值语法的区别： v-text会替换节点中的内容， {{xx}}不会。
12. v-html：向指定节点渲染包含html结构的内容。v-html会替换掉节点的所有内容，{{xxx}}不会，v-html可以识别html结构。**注意：**在网站上动态渲染任意html时非常危险的，容易导致xss攻击；一定要在可信的内容上使用v-html，永远不要用在用户提交的内容上。

## v-show和v-if指令的共同点和不同点

### 共同点：

v-show和v-if都能控制元素的显示和隐藏。

### 不同点

1. 实现本质方法不同：v-show本质就是通过设置css中的display设置为none；控制隐藏v-if是动态的向DOM树内添加或者删除DOM元素。
2. v-show都会编译，初始值为false，只是将display设为none，但它也编译了；v-if初始值为false，就不会编译了。

**总结**：v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，如果要频繁切换某节点时，故v-show性能更好一点。

## 为什么避免v-if和v-for一起使用

vue2.x版本中，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级；
vue3.x版本中，当 v-if 与 v-for 一起使用时，v-if 具有比 v-for 更高的优先级。
官网明确指出：避免 v-if 和 v-for 一起使用，永远不要在一个元素上同时使用 v-if 和 v-for。

## Vue.set 改变数组和对象中的属性

在一个组件实例中，只有在data里初始化的数据才是响应的，Vue不能检测到对象属性的添加或删除，没有在data里声明的属性不是响应的,所以数据改变了但是不会在页面渲染；
**解决办法：**使用 Vue.set(object, key, value) / vm.$set(obj, key, val)方法将响应属性添加到嵌套的对象上。

## 第一次页面加载会触发哪几个钩子

第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子。

## vue组件通信有哪些方式

1. 父传子：props
   父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed
2. 子传父：通过自定义事件形式
   子组件通过 $emit()给父组件发送消息，父组件通过v-on绑定事件接收数据。
3. 父子、兄弟、跨级：eventBus.js全局事件总线
   这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心）,用它来（e m i t ） 触 发 事 件 和 （ emit）触发事件和（emit）触发事件和（on）监听事件，巧妙而轻量地实现了任何组件间的通信。
4. 通信插件：PubSub.js 消息订阅与发布。
5. vuex
   vuex 是 vue 的状态管理器，存储的数据是响应式的。只需要把共享的值放到vuex中，其他需要的组件直接获取使用即可。

## Computed 和 Watch 的区别

### Computed

**作用**

1. 解决模板中放入过多的逻辑会让模板过重且难以维护的问题。例如两个数据的拼接或字体颜色的判断。
2. 它**支持缓存**，只有依赖的数据发生了变化，才会重新计算。例如模板中多次用到数据拼接可以用计算属性，只执行一次计算，除非数据发生变化。
3. **不支持异步**，如果有异步操作，无法监听数据的变化。
4. 如果属性值是函数，默认使用get方法，函数的返回值就是属性的属性值。还有一个set方法，当数据变化时就会调用set方法。
5. computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。

### Watch

**作用**

1. 它不支持缓存，数据变化时，它就会触发相应的操作。
2. 支持异步监听。
3. 接受两个参数，第一个是最新的值，第二个是变化之前的值。
4. 监听data或者props传来的数据，发生变化时会触发相应操作。

### 总结

1. **computed** 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。
2. **watch** 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。

### 场景

1. **computed**：是多对一，多个数据影响一个。当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。
2. watch：是一对多，一个数据发生变化，执行相应操作会影响多个数据。当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

## 自定义指令

逻辑复用，跟操作DOM有关。对普通DOM元素进行底层操作。

1. bind：指令与元素成功绑定时调用。
2. inserted：指令所在元素被插入页面时调用。
3. update：指令所在模板结构被重新解析时调用。